#!/usr/bin/env python
# (C) Copyright NuoDB, Inc. 2019  All Rights Reserved.

"""
Command-line tool for building the NuoDB client package.
"""

import os
import sys
import argparse
import re

from string import Template
from datetime import datetime

from client.exceptions import ClientError
from client.package import Package
from client.utils import Globals, info
from client.utils import run, runout, mkdir, rmdir, rmfile, rmrf
from client.utils import copyinto, copyfiles, loadfile, savefile

# Import all packages.  This forces them to register themselves.
from client.pkg import *

# Also disable any per-user site-packages for safety
os.environ['PYTHONNOUSERSITE'] = 'true'

os.environ['LC_ALL'] = 'C'
os.environ['LANG'] = 'C'

# Turn off file extension saving for tar (in MacOS)
os.environ['COPYFILE_DISABLE'] = 'true'

USER = 'nuodb'
GROUP = 'nuodb'

PYTHONVERSION = 3


def build_clients(packages):
    buildid = Globals.buildid
    (ret, out, err) = runout(['git', 'rev-parse', '--short=10', 'HEAD'])
    commit = out if ret == 0 else 'UNK'

    target = Globals.target
    pkgname_template = 'nuodb-{}-{}.{}'

    # This is handled inside Package so it can deal with prerequisites etc.
    Package.build_all(packages)

    # Track all package names to return later
    pkgnames = set()

    # We want to recreate each pkgdir when it is first used
    pkgdir_cleaned = set()
    def clean_pkgdir(d):
        if d in pkgdir_cleaned:
            return
        rmdir(d)
        mkdir(d)
        pkgdir_cleaned.add(d)

    # Now construct the final package from all the individual dist directories
    staged = []
    for pkgnm in packages:
        pkg = Package.get_package(pkgnm)

        # Get the version from the package
        # Currently all stages in a package have the same version
        version = pkg.staged[0].version

        info("Installing package {} ...".format(pkg.name))
        for stg in pkg.staged:
            staged.append(stg)
            pkgname = pkgname_template.format(stg.bundle.value, version, target)
            pkgnames.add(pkgname)
            pkgdir = os.path.join(Globals.finalroot, pkgname)
            clean_pkgdir(pkgdir)
            copyinto(stg.stagedir, pkgdir)

    manifest = []
    packages = []
    for stg in sorted(staged, key=lambda x: x.title):
        manifest.append('  * {} version {}'.format(stg.title, stg.version))
        if stg.notes is None:
            notes = ''
        else:
            notes = '\nNotes:{}'.format(stg.notes)
        packages.append("""{}
{}

Version: {}
Requirements: {}{}

Contents:
  {}""".format(stg.title,
               '-'*len(stg.title),
               stg.version,
               stg.requirements,
               notes,
               '\n  '.join(sorted(stg.getcontents()))))

    # Construct the various values for the README file
    replace = {'VERSION': version,
               'BUILD': buildid,
               'COMMIT': commit,
               'LICENSE': Package.getlicense('3BSD'),
               'MANIFEST': '\n'.join(manifest),
               'PACKAGES': '\n\n'.join(packages)}

    readme = loadfile('README.in')
    savefile(os.path.join(pkgdir, 'README.txt'),
             Template(readme).substitute(replace))

    etc = os.path.join(pkgdir, 'etc')
    mkdir(etc)
    if Globals.target.startswith('lin'):
        copyfiles(['nuodb_setup.sh'], Globals.etcdir, etc)
    else:
        copyfiles(['nuodb_setup.bat'], Globals.etcdir, etc)

    return pkgnames


def create_package(pkgname):
    if Globals.target.startswith('lin'):
        out = '{}.tar.gz'.format(pkgname)
        rmfile(out)
        info("Creating {} ...".format(out))
        run(['tar', '-c', '-z', '-f', out, '--owner=%s' % USER, '--group=%s' % GROUP, pkgname], cwd=Globals.finalroot)
    else:
        out = '{}.zip'.format(pkgname)
        rmfile(out)
        info("Creating {} ...".format(out))
        run(['zip', '-r', out, pkgname], cwd=Globals.finalroot)


def main():
    Globals.init(clientroot=os.path.dirname(os.path.realpath(__file__)),
                 pythonversion=PYTHONVERSION)

    # Get a list of possible packages
    packages = Package.get_packages()

    parser = argparse.ArgumentParser(description='Build the NuoDB Client package')

    parser.add_argument(
        "-i",
        "--info",
        action="store_true",
        help="Show information about known client packages")

    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Show verbose output")

    parser.add_argument(
        "-p",
        "--platform",
        default='lin-x64',
        choices=['lin-x64', 'lin-arm64', 'win-x64'],
        help="Client platform")

    parser.add_argument(
        "--no-package",
        action="store_true",
        help="Don't create the final tarball/zip file.")

    parser.add_argument(
        "--clean",
        action="store_true",
        help="Clean previous builds.  Downloads are not cleaned.")

    parser.add_argument(
        "--build",
        default=0,
        help="NuoDB Client build number")

    parser.add_argument(
        "--real-clean",
        action="store_true",
        help="Clean previous builds and downloads.")

    parser.add_argument(
        'packages',
        metavar='PKGS',
        nargs='*',
        help='Packages to be built')

    options = parser.parse_args()

    kwargs = {'isverbose': options.verbose,
              'target': options.platform,
              'buildid': options.build}

    for arg in list(options.packages):
        m = re.match(r'([^=]+)=([^\d].*)', arg)
        if m is None:
            if arg != 'all' and arg not in packages:
                sys.exit("Invalid package '%s': must be one of:\n    all, %s"
                         % (arg, ', '.join(packages)))
        else:
            kwargs[m.group(1)] = m.group(2)
            options.packages.remove(arg)

    if not options.packages:
        options.packages = ['all']

    Globals.setup(**kwargs)

    try:
        if options.clean or options.real_clean:
            if 'all' in options.packages:
                info("Cleaning all packages ...")
                rmrf([Globals.tmproot, Globals.finalroot])
                if options.real_clean:
                    info("Cleaning downloads ...")
                    rmdir(Globals.downloadroot)
            else:
                for name in options.packages:
                    pkg = Package.get_package(name)
                    info('{}: Cleaning'.format(name))
                    pkg.clean(real=options.real_clean)
            return

        if 'all' in options.packages:
            options.packages = packages

        pkgnames = build_clients(options.packages)

        if not options.no_package:
            for pkgname in pkgnames:
                create_package(pkgname)

    except ClientError as ex:
        sys.exit("Failed: {}".format(str(ex)))


main()
